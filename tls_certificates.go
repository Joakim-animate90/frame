package frame

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"errors"
	"fmt"
	"golang.org/x/net/http2"
	"log"
	"math/big"
	"os"
	"time"
)

// generateTLSCertificate generates the TLS keypair for the server
func generateTLSCertificate(domainNames []string, commonName, country, organization, organizationUnit string, validityYears, validityMonths, validityDays int) (*tls.Certificate, error) {

	now := time.Now()
	//
	//privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	//if err != nil {
	//	return nil, err
	//}

	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return nil, err
	}

	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		return nil, err
	}

	template := &x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName:         commonName,
			Country:            []string{country},
			Organization:       []string{organization},
			OrganizationalUnit: []string{organizationUnit},
		},

		DNSNames: domainNames,

		NotBefore: now,
		NotAfter:  now.AddDate(validityYears, validityMonths, validityDays),

		BasicConstraintsValid: true,
		KeyUsage:              x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
	}

	cert, err := x509.CreateCertificate(rand.Reader, template, template,
		privateKey.Public(), privateKey)
	if err != nil {
		return nil, err
	}

	outCert := tls.Certificate{}
	outCert.Certificate = [][]byte{cert}
	outCert.PrivateKey = privateKey

	return &outCert, nil
}

func OutputGeneratedTLSCertificate(cert *tls.Certificate, certFile, keyFile string) error {

	pemCert := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: cert.Certificate[0]})
	if pemCert == nil {
		return errors.New("failed to encode certificate to PEM")
	}
	if err := os.WriteFile(certFile, pemCert, 0644); err != nil {
		return err
	}

	privBytes, err := x509.MarshalPKCS8PrivateKey(cert.PrivateKey)
	if err != nil {
		return fmt.Errorf("unable to marshal private key: %v", err)
	}
	pemKey := pem.EncodeToMemory(&pem.Block{Type: "PRIVATE KEY", Bytes: privBytes})
	if pemKey == nil {
		return fmt.Errorf("failed to encode key to PEM")
	}
	if err := os.WriteFile(keyFile, pemKey, 0600); err != nil {
		log.Fatal(err)
	}

	return nil
}

// TLSCertificateGenerate Option that configures tls certificates for the server, the certificate is autogenerated from the TLSCertificate environment variables
func TLSCertificateGenerate() Option {
	return func(s *Service) {
		config, ok := s.Config().(ConfigurationTLS)
		if !ok {
			s.L().Warn("configuration object not of type : ConfigurationTLS")
			return
		}

		cert, err := generateTLSCertificate(
			config.TLSCertDomains(),
			config.TLSCertCommonName(),
			config.TLSCertCountry(),
			config.TLSCertOrganization(),
			config.TLSCertOrganizationUnit(),
			config.TLSCertValidYears(),
			config.TLSCertValidMonths(),
			config.TLSCertValidDays())
		if err != nil {
			s.L().WithError(err).Error("could not generate the tls certificates")
		}
		certificatePath := "./server-cert.pem"
		certificateKeyPath := "./server-key.pem"
		err = OutputGeneratedTLSCertificate(cert, certificatePath, certificateKeyPath)
		if err != nil {
			s.L().WithError(err).Error("could not output generated tls certificates")
		}

		config.SetTLSCertAndKeyPath(certificatePath, certificateKeyPath)
		s.tlsEnabled = true

	}
}

func (s *Service) TLSEnabled() bool {
	config, ok := s.Config().(ConfigurationTLS)
	if !ok {
		return false
	}

	if _, err := os.Stat(config.TLSCertPath()); err != nil {
		return false
	}

	if _, err := os.Stat(config.TLSCertKeyPath()); err != nil {
		return false
	}
	return true
}

func (s *Service) TLSConfig() *tls.Config {

	if !s.TLSEnabled() {
		return nil
	}

	config, ok := s.Config().(ConfigurationTLS)
	if !ok {
		s.L().Error("tls certificate configuration not castable to : ConfigurationTLS")
		return nil
	}

	cert, err := tls.LoadX509KeyPair(config.TLSCertPath(), config.TLSCertKeyPath())
	if err != nil {
		s.L().WithError(err).Error("could not load cert")
		return nil
	}

	return &tls.Config{
		Certificates: []tls.Certificate{cert},
		NextProtos:   []string{http2.NextProtoTLS, "http/1.1"},
	}
}
